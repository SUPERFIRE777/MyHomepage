<!DOCTYPE html>
<html>
    <head>
        <title>数学</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="/style.css">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">
        <script src="/use-MathJax.js"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> 
        <script type="module" src="/script.js"></script>
    </head>
    <body>
        <h1>SUPERFIRE777のサイト</h1>
        <div id="nav-container"></div>
        <div id="breadcrumbs"></div>
        <div class="center">
            <h2>素因数分解</h2>
        </div>
        <h3>導入</h3>
        <p>素因数分解は、ある自然数を素数の積に分解することです。</p>
        <p>例えば、\(12 = 2^2\times3, 777 = 3\times7\times37\)となります。</p>
        <p>人力で素因数分解をするときには「すだれ算」とかいうのをしましたね。</p>
        <p>プログラムは\(n\)を入力として、\(2, 3, 4, 5, \cdots, n-1\)と順番に割っていくという単純なものが考えられます。</p>
        <p>割れたら割るので数がだんだん小さくなっていきます。</p>
        <p>しかし、素数を入力されると割れないので数が減りません。</p>
        <p><ruby>9007199254740881<rt>9007兆1992億5474万0881</rt></ruby>とかいうデカい素数を入力されたら、とんでもなく時間がかかってしまいます。</p>    
        <p>1秒に10億回ループできるとしても、3か月以上かかってしまいます。</p>
        <p>それではツールとして役に立たないので、あるテクニックを利用します。</p>
        <h3>テクニックその1</h3>
        <p>それは、<b>\(\sqrt{n}\)までで割り切れなければ処理を打ち切ってもよい</b>というものです。</p>
        <p>例えば、15が5で割れることを発見したとしましょう。</p>
        <p>ところが、2から順に割っていくと3で割れることがわかります。</p>
        <p>一般に、\(\sqrt{n}\)より大きい約数が存在するとしたら、\(\sqrt{n}\)より小さい約数も存在するはずです。</p>
        <p>なぜなら、\(\sqrt{n}\)より大きい約数\(a\)を見つけたら、\(\frac{n}{a}\)という\(\sqrt{n}\)より小さい約数も見つかるからです。</p>
        <p>つまり、\(\sqrt{n}\)より大きい整数を試すのは無駄であるということです。</p>
        <p>これを利用すると、割る数の最大値を\(\lfloor\sqrt{n}\rfloor\)まで一気に減らすことができます。</p>
        <p>これでかなりの高速化になりますが、素数のある特徴を利用すると、もう少し高速化できます。</p>
        <h3>テクニックその2</h3>
        <p>それは、<b>5以上の全ての素数は全て\(6n+1\)または\(6n-1\)(\(n\)は1以上の整数)の形になる</b>というものです。</p>
        <p>6で割った余りで分類して確かめてみます。</p>
        <table>
            <tr>
                <th>6で割ったあまり</th>
                <th>式</th>
                <th>分かること</th>
            </tr>
            <tr>
                <td>0</td>
                <td>\(6n+0 = 2\cdot3\cdot n\)</td>
                <td>2と3で割れる</td>
            </tr>
            <tr>
                <td>1</td>
                <td>\(6n+1\)</td>
                <td>2でも3でも割れない</td>
            </tr>
            <tr>
                <td>2</td>
                <td>\(6n+2 = 2(3n+1)\)</td>
                <td>2で割れる</td>
            </tr>
            <tr>
                <td>3</td>
                <td>\(6n+3 = 3(2n+1)\)</td>
                <td>3で割れる</td>
            </tr>
            <tr>
                <td>4</td>
                <td>\(6n+4 = 2(3n+2)\)</td>
                <td>2で割れる</td>
            </tr>
            <tr>
                <td>5</td>
                <td>\(6n+5\)</td>
                <td>2でも3でも割れない</td>
            </tr>
        </table>
        <p>\(6n+1\)と\(6n+5\)は素数かどうかはわかりませんが、それ以外の数は確実に素数でないことがわかります。</p>
        <p>\(n = 1\)のとき、\(6n - 1 = 5\)なので、\(6n+5\)は\(6n-1\)に書き直せます。</p>
        <p>つまり、5以上の素数は\(6n+1\)または\(6n-1\)の形で表すことができ、それ以外の数で割るのは無駄ということがわかります。</p>
        <p>これで割る数が約1/3に減りました。</p>
        <h4>終わりに</h4>
        <p>ツールの素因数分解は、これらのテクニックを使用して高速化を図っています。</p>
        <p>それでも環境次第では時間かかりますが。</p>
    </body>    
</html>
